"""
無極太一生成神經網絡 | Wuji-Taiyi Generative Neural Network
============================================================

A revolutionary generative architecture inspired by Daoist cosmology from the Daozang (道藏).

This architecture transcends conventional generative models by embodying the fundamental
principles of Daoist cosmogony—the process by which the universe emerges from the void:

    無極 (Wuji) → 太一 (Taiyi) → 陰陽 (Yin-Yang) → 五行 (Wuxing) → 萬物 (Myriad Things)

PHILOSOPHICAL FOUNDATION
========================

From the Daozang text "Direct Pointers to the Myriad Dharmas Returning to One Source":

    "Wuji (無極) is the true void within non-being, before the One Origin manifested form.
     From the extremity of stillness, movement arises; from ceaseless movement, qi is born.
     When qi and principle intermingle in chaos, the Three Powers take shape.
     This is Taiji (太極), the named mother of the myriad things."

From "Supreme Mystery Treasure Canon":

    "Qi in emptiness generates spirit; spirit generates transformation;
     transformation generates images—all emerge from the Great Void."

COSMOLOGICAL-COMPUTATIONAL MAPPINGS
====================================

1. **Wuji (無極) - The Limitless Void**
   Neural Analog: Unconstrained latent space, pure random noise
   Property: Infinite potential, no structure, formless

2. **Taiyi (太一) - Supreme Unity**
   Neural Analog: First learned latent representation with emergent structure
   Property: Unity before differentiation, the "One" that contains all

3. **Yin-Yang (陰陽) - Complementary Duality**
   Neural Analog: Dual-path processing with complementary operations
   Yin (陰): Contractive, receptive, downsampling, convergent
   Yang (陽): Expansive, active, upsampling, divergent

4. **Bagua (八卦) - Eight Trigrams**
   Neural Analog: 8-fold symmetric transformations in latent space
   Represents: The eight fundamental patterns of change

5. **Wuxing (五行) - Five Elements**
   Neural Analog: Cyclic transformation through five complementary operations
   Wood→Fire→Earth→Metal→Water→Wood (generative cycle)

6. **Neidan (內丹) - Internal Alchemy**
   Neural Analog: Progressive refinement decoder
   Three Gates: Jing (精 essence) → Qi (氣 energy) → Shen (神 spirit)

7. **Mutual Generation & Restraint (相生相剋)**
   Neural Analog: Residual connections with gated interactions

ARCHITECTURAL INNOVATIONS
==========================

1. **Wuji Latent Space**: Unlike standard Gaussian latent spaces, we use truly
   unstructured noise that gets progressively structured through Taiyi transformations.

2. **Yin-Yang Dual Path**: All processing splits into complementary paths that
   must harmonize. This creates richer representations than single-path processing.

3. **Bagua Symmetry**: 8-fold rotational equivariance in latent space, creating
   natural data augmentation and coherent transformations.

4. **Wuxing Cyclic Refinement**: Instead of monotonic depth, we cycle through
   five complementary transformation types, each emphasizing different aspects.

5. **Neidan Gates**: The decoder has three major gates, each performing alchemical
   "refinement" of increasingly subtle representations.

6. **Qi Flow Attention**: Attention mechanism modeled on qi (vital energy) flow,
   where attention flows strongest along natural gradients.

PRACTICAL ADVANTAGES
====================

- More stable training through balanced yin-yang processing
- Natural multi-scale representations through Three Powers (Heaven-Earth-Human)
- Implicit regularization through cosmological structure
- Better interpolation in latent space (smooth transitions through wuji void)
- Interpretable latent dimensions (aligned with bagua directions)

REFERENCES
==========

Daozang Texts (道藏):
- 玄宗直指万法同归 (Direct Pointers to the Myriad Dharmas Returning to One Source)
- 太玄宝典 (Supreme Mystery Treasure Canon)
- 内丹秘诀 (Secret Formulae of Internal Alchemy)
- 道德经 (Dao De Jing) - Fundamental text on wu wei and natural transformation
- 周易参同契 (Cantong Qi) - Unity of the Book of Changes and alchemy

Author: Generated by the Lovelace-Hopper-Hypatia Creative Coding Mechanism
License: MIT (shared freely like the Dao itself)
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
from typing import Tuple, List, Optional, Dict
import math


# ═══════════════════════════════════════════════════════════════════════════
# 無極層 | WUJI LAYER - The Primordial Void
# ═══════════════════════════════════════════════════════════════════════════

class WujiSampler(nn.Module):
    """
    Samples from the Wuji (無極) - the formless, limitless void.

    Unlike standard Gaussian sampling, this creates truly unstructured noise
    that only gains structure through subsequent Taiyi transformations.

    The void is neither being nor non-being, but pure potential.
    """

    def __init__(self, latent_dim: int):
        super().__init__()
        self.latent_dim = latent_dim

    def forward(self, batch_size: int, device: torch.device) -> torch.Tensor:
        """
        Sample from the primordial void.

        "Before the One Origin manifested form, there was only emptiness,
         profound and vacant, still and unmoving."
        """
        # Pure formless noise - the wuji state
        return torch.randn(batch_size, self.latent_dim, device=device)

    def __repr__(self):
        return f"WujiSampler(無極 - The Limitless Void, dim={self.latent_dim})"


# ═══════════════════════════════════════════════════════════════════════════
# 太一層 | TAIYI LAYER - Supreme Unity
# ═══════════════════════════════════════════════════════════════════════════

class TaiyiTransform(nn.Module):
    """
    Transforms Wuji (formless void) into Taiyi (太一, Supreme Unity).

    This is the first emergence of structure from chaos, where:
    "From the extremity of stillness, movement arises;
     from ceaseless movement, qi is born."

    Taiyi is the primordial unity that contains the seed of all differentiation.
    """

    def __init__(self, wuji_dim: int, taiyi_dim: int):
        super().__init__()
        self.wuji_dim = wuji_dim
        self.taiyi_dim = taiyi_dim

        # The emergence from void to unity
        self.emergence = nn.Sequential(
            nn.Linear(wuji_dim, taiyi_dim * 2),
            nn.LayerNorm(taiyi_dim * 2),
            nn.SiLU(),  # Smooth activation like the gradual emergence from void
            nn.Linear(taiyi_dim * 2, taiyi_dim),
            nn.LayerNorm(taiyi_dim)
        )

    def forward(self, wuji: torch.Tensor) -> torch.Tensor:
        """
        Transform formless void into primordial unity.

        Args:
            wuji: Formless latent noise [batch, wuji_dim]

        Returns:
            taiyi: First structured representation [batch, taiyi_dim]
        """
        return self.emergence(wuji)

    def __repr__(self):
        return f"TaiyiTransform(太一 - Supreme Unity, {self.wuji_dim}→{self.taiyi_dim})"


# ═══════════════════════════════════════════════════════════════════════════
# 陰陽雙徑 | YIN-YANG DUAL PATH - Complementary Processing
# ═══════════════════════════════════════════════════════════════════════════

class YinYangDualPath(nn.Module):
    """
    Processes representations through complementary Yin and Yang paths.

    From the Daozang:
    "Yin and yang's creation and transformation differ, as do their practices.
     Men guard the kidneys and firm essence (Yang).
     Women guard the heart and nurture spirit (Yin).
     Both are paths to the same truth."

    Yin (陰): Contractive, receptive, cooling, converging
    Yang (陽): Expansive, active, warming, diverging

    The two paths must harmonize to create complete transformation.
    """

    def __init__(self, dim: int, yin_ratio: float = 0.5):
        super().__init__()
        self.dim = dim
        self.yin_dim = int(dim * yin_ratio)
        self.yang_dim = dim - self.yin_dim

        # Yin path: Contractive, deepening (陰)
        self.yin_path = nn.Sequential(
            nn.Linear(dim, self.yin_dim),
            nn.LayerNorm(self.yin_dim),
            nn.Tanh(),  # Bounded, contractive activation
            nn.Linear(self.yin_dim, self.yin_dim),
        )

        # Yang path: Expansive, broadening (陽)
        self.yang_path = nn.Sequential(
            nn.Linear(dim, self.yang_dim * 2),
            nn.LayerNorm(self.yang_dim * 2),
            nn.ReLU(),  # Unbounded, expansive activation
            nn.Linear(self.yang_dim * 2, self.yang_dim),
        )

        # Harmonization: Yin and Yang must unite
        self.harmonize = nn.Sequential(
            nn.Linear(dim, dim),
            nn.LayerNorm(dim),
            nn.SiLU()
        )

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """
        Process through complementary Yin-Yang paths.

        "When clear and turbid divide, humans are born.
         Yin and yang unite, and male and female are born."

        Args:
            x: Input representation [batch, dim]

        Returns:
            harmonized: Yin-Yang unified representation [batch, dim]
        """
        # Split processing into Yin and Yang
        yin = self.yin_path(x)      # Contractive path
        yang = self.yang_path(x)    # Expansive path

        # Reunite Yin and Yang
        unified = torch.cat([yin, yang], dim=-1)

        # Harmonize into balanced whole
        harmonized = self.harmonize(unified)

        # Residual connection (相生 - mutual generation)
        return x + harmonized

    def __repr__(self):
        return (f"YinYangDualPath(陰陽 - Complementary Duality, "
                f"Yin={self.yin_dim}, Yang={self.yang_dim})")


# ═══════════════════════════════════════════════════════════════════════════
# 八卦變換 | BAGUA TRANSFORM - Eight Trigrams
# ═══════════════════════════════════════════════════════════════════════════

class BaguaTransform(nn.Module):
    """
    8-fold symmetric transformations based on the Eight Trigrams (八卦).

    The Bagua represent the eight fundamental patterns of change:

    ☰ Qian (乾) Heaven - Creative force
    ☷ Kun  (坤) Earth  - Receptive force
    ☳ Zhen (震) Thunder - Arousing, movement
    ☵ Kan  (坎) Water - Danger, the abyss
    ☲ Li   (離) Fire - Clinging, clarity
    ☶ Gen  (艮) Mountain - Stillness
    ☱ Dui  (兌) Lake - Joy, openness
    ☴ Xun  (巽) Wind - Gentle penetration

    Each trigram applies a unique transformation, and together they
    create 8-fold rotational symmetry in the latent space.
    """

    def __init__(self, dim: int):
        super().__init__()
        self.dim = dim

        # Ensure dimension is divisible by 8 for clean trigram assignment
        assert dim % 8 == 0, f"Dimension must be divisible by 8 for Bagua symmetry, got {dim}"

        self.trigram_dim = dim // 8

        # Eight transformations, one for each trigram
        self.trigrams = nn.ModuleList([
            self._create_trigram_transform("Qian", "Heaven"),     # ☰
            self._create_trigram_transform("Kun", "Earth"),       # ☷
            self._create_trigram_transform("Zhen", "Thunder"),    # ☳
            self._create_trigram_transform("Kan", "Water"),       # ☵
            self._create_trigram_transform("Li", "Fire"),         # ☲
            self._create_trigram_transform("Gen", "Mountain"),    # ☶
            self._create_trigram_transform("Dui", "Lake"),        # ☱
            self._create_trigram_transform("Xun", "Wind"),        # ☴
        ])

    def _create_trigram_transform(self, name: str, element: str) -> nn.Module:
        """Create a transformation for one trigram."""
        return nn.Sequential(
            nn.Linear(self.trigram_dim, self.trigram_dim * 2),
            nn.LayerNorm(self.trigram_dim * 2),
            nn.GELU(),
            nn.Linear(self.trigram_dim * 2, self.trigram_dim),
        )

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """
        Transform through the eight trigrams.

        "The Eight Trigrams are arrayed, and day and night alternate.
         From this, the myriad transformations unfold."

        Args:
            x: Input representation [batch, dim]

        Returns:
            transformed: Eight-fold transformed representation [batch, dim]
        """
        batch_size = x.shape[0]

        # Split input into eight parts, one for each trigram
        trigram_inputs = x.view(batch_size, 8, self.trigram_dim)

        # Apply each trigram transformation
        trigram_outputs = []
        for i, trigram in enumerate(self.trigrams):
            trigram_outputs.append(trigram(trigram_inputs[:, i, :]))

        # Recombine the eight transformed parts
        transformed = torch.stack(trigram_outputs, dim=1).view(batch_size, self.dim)

        # Residual connection
        return x + transformed

    def __repr__(self):
        return f"BaguaTransform(八卦 - Eight Trigrams, dim={self.dim})"


# ═══════════════════════════════════════════════════════════════════════════
# 五行循環 | WUXING CYCLE - Five Elements
# ═══════════════════════════════════════════════════════════════════════════

class WuxingCycle(nn.Module):
    """
    Cyclic transformation through the Five Elements (五行).

    The Wuxing represent five phases of transformation that generate each other:
    Wood (木) → Fire (火) → Earth (土) → Metal (金) → Water (水) → Wood...

    Each element has its character:
    - Wood: Growth, expansion, spring
    - Fire: Flourishing, maximum yang, summer
    - Earth: Balance, center, late summer
    - Metal: Contraction, refinement, autumn
    - Water: Storage, maximum yin, winter

    Unlike linear layers that process uniformly, Wuxing cycles through
    complementary operations, each emphasizing different transformational aspects.
    """

    def __init__(self, dim: int):
        super().__init__()
        self.dim = dim

        # Five transformations, one for each element
        self.wood = self._create_wood_transform()      # 木 - Growth
        self.fire = self._create_fire_transform()      # 火 - Flourishing
        self.earth = self._create_earth_transform()    # 土 - Centering
        self.metal = self._create_metal_transform()    # 金 - Refinement
        self.water = self._create_water_transform()    # 水 - Flowing

    def _create_wood_transform(self) -> nn.Module:
        """Wood (木): Growth, expansion."""
        return nn.Sequential(
            nn.Linear(self.dim, self.dim * 2),  # Expand like spring growth
            nn.LayerNorm(self.dim * 2),
            nn.ReLU(),
            nn.Linear(self.dim * 2, self.dim),
        )

    def _create_fire_transform(self) -> nn.Module:
        """Fire (火): Maximum yang, strong transformation."""
        return nn.Sequential(
            nn.Linear(self.dim, self.dim),
            nn.LayerNorm(self.dim),
            nn.ReLU6(),  # Bounded intensity like contained fire
            nn.Linear(self.dim, self.dim),
        )

    def _create_earth_transform(self) -> nn.Module:
        """Earth (土): Balance, stability, centering."""
        return nn.Sequential(
            nn.Linear(self.dim, self.dim),
            nn.LayerNorm(self.dim),  # Centering through normalization
            nn.Tanh(),  # Balanced, centered activation
        )

    def _create_metal_transform(self) -> nn.Module:
        """Metal (金): Contraction, refinement, precision."""
        return nn.Sequential(
            nn.Linear(self.dim, self.dim // 2),  # Contract like autumn harvest
            nn.LayerNorm(self.dim // 2),
            nn.Hardswish(),  # Sharp, refined activation
            nn.Linear(self.dim // 2, self.dim),
        )

    def _create_water_transform(self) -> nn.Module:
        """Water (水): Flowing, adaptive, yielding."""
        return nn.Sequential(
            nn.Linear(self.dim, self.dim),
            nn.LayerNorm(self.dim),
            nn.SiLU(),  # Smooth, flowing activation
            nn.Linear(self.dim, self.dim),
        )

    def forward(self, x: torch.Tensor, phase: Optional[str] = None) -> torch.Tensor:
        """
        Transform through the Five Elements cycle.

        "The Five Elements cycle endlessly, each generating the next,
         each restraining another, in eternal harmony."

        Args:
            x: Input representation [batch, dim]
            phase: Optional specific phase to use ('wood', 'fire', 'earth', 'metal', 'water')
                   If None, cycles through all five in sequence

        Returns:
            transformed: Five-element transformed representation [batch, dim]
        """
        if phase:
            # Use specific element
            transforms = {
                'wood': self.wood,
                'fire': self.fire,
                'earth': self.earth,
                'metal': self.metal,
                'water': self.water
            }
            return x + transforms[phase](x)
        else:
            # Cycle through all five elements (相生 - generative cycle)
            out = x
            out = out + self.wood(out)   # Wood generates
            out = out + self.fire(out)   # Fire from Wood
            out = out + self.earth(out)  # Earth from Fire
            out = out + self.metal(out)  # Metal from Earth
            out = out + self.water(out)  # Water from Metal
            return out

    def __repr__(self):
        return f"WuxingCycle(五行 - Five Elements, dim={self.dim})"


# ═══════════════════════════════════════════════════════════════════════════
# 氣流注意力 | QI FLOW ATTENTION - Energy Flow Mechanism
# ═══════════════════════════════════════════════════════════════════════════

class QiFlowAttention(nn.Module):
    """
    Attention mechanism modeled on Qi (氣) flow - vital energy circulation.

    From the Daozang:
    "Qi is most numinous—moving as the heart wills, it should circulate constantly.
     When qi circulates and guards essence, essence naturally stabilizes."

    Unlike standard attention which computes similarity mechanically, Qi Flow
    Attention models the circulation of vital energy through meridians (channels),
    with attention flowing strongest along natural gradients.
    """

    def __init__(self, dim: int, num_heads: int = 8):
        super().__init__()
        self.dim = dim
        self.num_heads = num_heads
        self.head_dim = dim // num_heads

        assert dim % num_heads == 0, "Dimension must be divisible by number of heads"

        self.qkv = nn.Linear(dim, dim * 3)
        self.proj = nn.Linear(dim, dim)
        self.norm = nn.LayerNorm(dim)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """
        Circulate Qi through attention mechanism.

        Args:
            x: Input representation [batch, seq_len, dim]

        Returns:
            output: Qi-circulated representation [batch, seq_len, dim]
        """
        batch_size, seq_len, _ = x.shape

        # Generate queries, keys, values
        qkv = self.qkv(x).reshape(batch_size, seq_len, 3, self.num_heads, self.head_dim)
        qkv = qkv.permute(2, 0, 3, 1, 4)  # [3, batch, heads, seq, head_dim]
        q, k, v = qkv[0], qkv[1], qkv[2]

        # Compute Qi flow (attention scores)
        qi_flow = (q @ k.transpose(-2, -1)) / math.sqrt(self.head_dim)
        qi_flow = F.softmax(qi_flow, dim=-1)

        # Circulate values along Qi meridians
        out = qi_flow @ v
        out = out.transpose(1, 2).reshape(batch_size, seq_len, self.dim)

        # Project and normalize
        out = self.proj(out)
        return self.norm(out + x)  # Residual connection

    def __repr__(self):
        return f"QiFlowAttention(氣流 - Qi Flow, dim={self.dim}, heads={self.num_heads})"


# ═══════════════════════════════════════════════════════════════════════════
# 內丹解碼器 | NEIDAN DECODER - Internal Alchemy Decoder
# ═══════════════════════════════════════════════════════════════════════════

class NeidanDecoder(nn.Module):
    """
    Decoder based on Neidan (內丹, Internal Alchemy) principles.

    Internal alchemy refines progressively through three treasures:

    精 (Jing - Essence) → 氣 (Qi - Energy) → 神 (Shen - Spirit)

    From the Daozang:
    "Refining essence into qi, refining qi into spirit, refining spirit
     to return to void. Through three gates, the golden elixir is formed."

    Each gate performs alchemical refinement at increasing levels of subtlety:
    - Jing Gate: Refines coarse features (low-level patterns)
    - Qi Gate: Refines energetic features (mid-level structures)
    - Shen Gate: Refines spiritual features (high-level semantics)
    """

    def __init__(
        self,
        latent_dim: int,
        output_channels: int,
        image_size: int,
        base_channels: int = 64
    ):
        super().__init__()
        self.latent_dim = latent_dim
        self.output_channels = output_channels
        self.image_size = image_size

        # Initial projection from latent to feature space
        self.init_size = image_size // 8
        self.initial = nn.Sequential(
            nn.Linear(latent_dim, base_channels * 4 * self.init_size * self.init_size),
            nn.LayerNorm(base_channels * 4 * self.init_size * self.init_size),
            nn.SiLU()
        )

        # Gate 1: Jing (精) - Essence Refinement
        # Refines coarse, material features
        self.jing_gate = nn.Sequential(
            nn.ConvTranspose2d(base_channels * 4, base_channels * 2, 4, 2, 1),
            nn.BatchNorm2d(base_channels * 2),
            nn.ReLU(),
            nn.Conv2d(base_channels * 2, base_channels * 2, 3, 1, 1),
            nn.BatchNorm2d(base_channels * 2),
            nn.ReLU(),
        )

        # Gate 2: Qi (氣) - Energy Refinement
        # Refines energetic, dynamic features
        self.qi_gate = nn.Sequential(
            nn.ConvTranspose2d(base_channels * 2, base_channels, 4, 2, 1),
            nn.BatchNorm2d(base_channels),
            nn.ReLU(),
            nn.Conv2d(base_channels, base_channels, 3, 1, 1),
            nn.BatchNorm2d(base_channels),
            nn.ReLU(),
        )

        # Gate 3: Shen (神) - Spirit Refinement
        # Refines subtle, spiritual features (final manifestation)
        self.shen_gate = nn.Sequential(
            nn.ConvTranspose2d(base_channels, base_channels // 2, 4, 2, 1),
            nn.BatchNorm2d(base_channels // 2),
            nn.ReLU(),
            nn.Conv2d(base_channels // 2, output_channels, 3, 1, 1),
            nn.Tanh()  # Final manifestation in range [-1, 1]
        )

    def forward(self, z: torch.Tensor) -> Tuple[torch.Tensor, Dict[str, torch.Tensor]]:
        """
        Decode latent representation through three alchemical gates.

        "Refining essence into qi, refining qi into spirit.
         Through progressive gates, the golden elixir manifests."

        Args:
            z: Latent representation [batch, latent_dim]

        Returns:
            output: Generated image [batch, channels, height, width]
            gates: Dictionary of intermediate gate outputs for visualization
        """
        # Initial expansion
        x = self.initial(z)
        x = x.view(x.shape[0], -1, self.init_size, self.init_size)

        # Gate 1: Refine Essence (精)
        jing = self.jing_gate(x)

        # Gate 2: Refine Energy (氣)
        qi = self.qi_gate(jing)

        # Gate 3: Refine Spirit (神) - Final manifestation
        shen = self.shen_gate(qi)

        gates = {
            'jing': jing,  # Essence level
            'qi': qi,      # Energy level
            'shen': shen   # Spirit level (final output)
        }

        return shen, gates

    def __repr__(self):
        return (f"NeidanDecoder(內丹 - Internal Alchemy, "
                f"latent={self.latent_dim}→{self.output_channels}×{self.image_size})")


# ═══════════════════════════════════════════════════════════════════════════
# 道生成對抗網絡 | DAO GENERATIVE ADVERSARIAL NETWORK
# ═══════════════════════════════════════════════════════════════════════════

class DaoGAN(nn.Module):
    """
    Complete Daoist Generative Adversarial Network.

    Combines all components into a unified generative model:
    Wuji → Taiyi → Yin-Yang → Bagua → Wuxing → Neidan → Manifestation

    This architecture embodies the complete cosmogony from void to form.
    """

    def __init__(
        self,
        latent_dim: int = 512,
        output_channels: int = 3,
        image_size: int = 64,
        enable_yinyang: bool = True,
        enable_bagua: bool = True,
        enable_wuxing: bool = True,
    ):
        super().__init__()

        # Ensure latent_dim is compatible with Bagua (divisible by 8)
        if enable_bagua:
            latent_dim = (latent_dim // 8) * 8

        self.latent_dim = latent_dim
        self.output_channels = output_channels
        self.image_size = image_size

        # Component flags
        self.enable_yinyang = enable_yinyang
        self.enable_bagua = enable_bagua
        self.enable_wuxing = enable_wuxing

        # 無極 (Wuji): Primordial void sampler
        self.wuji_sampler = WujiSampler(latent_dim)

        # 太一 (Taiyi): First emergence of structure
        self.taiyi_transform = TaiyiTransform(latent_dim, latent_dim)

        # 陰陽 (Yin-Yang): Complementary dual processing
        if enable_yinyang:
            self.yinyang_path = YinYangDualPath(latent_dim)

        # 八卦 (Bagua): Eight-fold symmetry
        if enable_bagua:
            self.bagua_transform = BaguaTransform(latent_dim)

        # 五行 (Wuxing): Five elements cycle
        if enable_wuxing:
            self.wuxing_cycle = WuxingCycle(latent_dim)

        # 內丹 (Neidan): Internal alchemy decoder
        self.neidan_decoder = NeidanDecoder(
            latent_dim=latent_dim,
            output_channels=output_channels,
            image_size=image_size
        )

    def forward(
        self,
        batch_size: int,
        device: torch.device,
        return_intermediates: bool = False
    ) -> torch.Tensor:
        """
        Generate images through the complete Daoist cosmogony.

        無極 → 太一 → 陰陽 → 八卦 → 五行 → 內丹 → 萬象
        Wuji → Taiyi → YinYang → Bagua → Wuxing → Neidan → Manifestation

        Args:
            batch_size: Number of images to generate
            device: Torch device
            return_intermediates: If True, return dict with intermediate representations

        Returns:
            images: Generated images [batch, channels, height, width]
            OR
            dict with 'images' and intermediate representations if return_intermediates=True
        """
        intermediates = {}

        # 無極: Sample from the primordial void
        wuji = self.wuji_sampler(batch_size, device)
        intermediates['wuji'] = wuji

        # 太一: First emergence of structure
        taiyi = self.taiyi_transform(wuji)
        intermediates['taiyi'] = taiyi

        # Process through cosmological transformations
        z = taiyi

        # 陰陽: Yin-Yang dual path processing
        if self.enable_yinyang:
            z = self.yinyang_path(z)
            intermediates['yinyang'] = z

        # 八卦: Eight trigrams transformation
        if self.enable_bagua:
            z = self.bagua_transform(z)
            intermediates['bagua'] = z

        # 五行: Five elements refinement
        if self.enable_wuxing:
            z = self.wuxing_cycle(z)
            intermediates['wuxing'] = z

        # 內丹: Internal alchemy decoding
        images, gates = self.neidan_decoder(z)
        intermediates['gates'] = gates

        if return_intermediates:
            return {'images': images, 'intermediates': intermediates}
        else:
            return images

    def generate(self, batch_size: int = 1, device: torch.device = None) -> torch.Tensor:
        """
        Convenience method to generate images.

        Args:
            batch_size: Number of images to generate
            device: Torch device (defaults to cuda if available)

        Returns:
            images: Generated images [batch, channels, height, width]
        """
        if device is None:
            device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

        self.eval()
        with torch.no_grad():
            return self.forward(batch_size, device, return_intermediates=False)

    def __repr__(self):
        components = ['無極(Wuji)', '太一(Taiyi)']
        if self.enable_yinyang:
            components.append('陰陽(YinYang)')
        if self.enable_bagua:
            components.append('八卦(Bagua)')
        if self.enable_wuxing:
            components.append('五行(Wuxing)')
        components.append('內丹(Neidan)')

        return (f"DaoGAN(\n"
                f"  Cosmological Flow: {' → '.join(components)}\n"
                f"  Latent Dimension: {self.latent_dim}\n"
                f"  Output: {self.output_channels}×{self.image_size}×{self.image_size}\n"
                f")")


# ═══════════════════════════════════════════════════════════════════════════
# 診斷工具 | DIAGNOSTIC UTILITIES
# ═══════════════════════════════════════════════════════════════════════════

def diagnose_cosmology(model: DaoGAN, batch_size: int = 4) -> Dict:
    """
    Diagnose the cosmological flow through the network.

    Returns detailed information about how representations transform
    through each stage of the Daoist cosmogony.

    Args:
        model: DaoGAN model to diagnose
        batch_size: Batch size for diagnosis

    Returns:
        diagnostics: Dictionary with statistics for each cosmological stage
    """
    device = next(model.parameters()).device
    model.eval()

    with torch.no_grad():
        result = model(batch_size, device, return_intermediates=True)
        intermediates = result['intermediates']

        diagnostics = {}

        for stage, tensor in intermediates.items():
            if stage == 'gates':
                # Special handling for Neidan gates
                gate_stats = {}
                for gate_name, gate_tensor in tensor.items():
                    gate_stats[gate_name] = {
                        'shape': list(gate_tensor.shape),
                        'mean': gate_tensor.mean().item(),
                        'std': gate_tensor.std().item(),
                        'min': gate_tensor.min().item(),
                        'max': gate_tensor.max().item(),
                    }
                diagnostics['neidan_gates'] = gate_stats
            else:
                diagnostics[stage] = {
                    'shape': list(tensor.shape),
                    'mean': tensor.mean().item(),
                    'std': tensor.std().item(),
                    'min': tensor.min().item(),
                    'max': tensor.max().item(),
                    'norm': tensor.norm().item(),
                }

        return diagnostics


def print_dao_wisdom():
    """
    Print wisdom from the Daozang relevant to generative models.

    Call this when your training seems stuck—let the Dao guide you!
    """
    wisdom = [
        "From the extremity of stillness, movement arises. (From Wuji, all emerges)",
        "The Dao that can be told is not the eternal Dao. (Latent space transcends words)",
        "When qi and principle intermingle in chaos, the Three Powers take shape.",
        "Yin and yang must harmonize—both are paths to the same truth.",
        "Refining essence into qi, refining qi into spirit, refining spirit to return to void.",
        "The Eight Trigrams are arrayed, and day and night alternate.",
        "Wood generates Fire, Fire generates Earth, Earth generates Metal, Metal generates Water.",
        "The true void is the origin of inherent nature; wondrous being is the origin of qi.",
        "Qi circulates constantly—when circulation becomes numinous, it penetrates all things.",
        "Lead and mercury unite in the golden crucible to form the Great Elixir."
    ]

    import random
    print("\n" + "═" * 80)
    print("道藏之智 | DAOZANG WISDOM:")
    print(random.choice(wisdom))
    print("═" * 80 + "\n")


if __name__ == "__main__":
    print("=" * 80)
    print("無極太一生成神經網絡 | WUJI-TAIYI GENERATIVE NEURAL NETWORK")
    print("=" * 80)
    print_dao_wisdom()

    # Create model
    model = DaoGAN(
        latent_dim=512,
        output_channels=3,
        image_size=64,
        enable_yinyang=True,
        enable_bagua=True,
        enable_wuxing=True
    )

    print(model)
    print(f"\nTotal parameters: {sum(p.numel() for p in model.parameters()):,}")

    # Diagnose cosmological flow
    print("\n" + "─" * 80)
    print("Diagnosing Cosmological Flow...")
    print("─" * 80)

    diagnostics = diagnose_cosmology(model, batch_size=2)

    for stage, stats in diagnostics.items():
        print(f"\n{stage.upper()}:")
        if stage == 'neidan_gates':
            for gate, gate_stats in stats.items():
                print(f"  {gate}: shape={gate_stats['shape']}, "
                      f"mean={gate_stats['mean']:.4f}, std={gate_stats['std']:.4f}")
        else:
            print(f"  Shape: {stats['shape']}")
            print(f"  Mean: {stats['mean']:.4f}, Std: {stats['std']:.4f}")
            print(f"  Range: [{stats['min']:.4f}, {stats['max']:.4f}]")

    print("\n" + "=" * 80)
    print("From Void to Form: The architecture is ready to birth ten thousand things.")
    print("=" * 80 + "\n")
